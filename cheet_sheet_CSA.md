# Клиент серверная архитектура(CSA)

Когда спрашивают про CSA спрашивают в контексте протокола http(протокол передачи гипертекста), у него есть определенная механика работы.
Суть механики -> клиент спрашивает у сервера, сервер получает запрос и отправляет ответ на запрос (получается пин понг спросил-ответил, спросил- ответил).
*это и есть логика http протокола, если рассматривать этот процесс высокоуровнево.*  

Причем клиент у сервера спрашивает в виде текстовой инфы, т.е. бежит текст по сети в виде запроса который является текстовым файлом в котором перечислено:
что вы спрашиваете, 
каким образом, 
каким URlом 
user-агентом, 
и какая инфа там лежит.
и сервер отвечает на клиент текстовым файлом RESPONSом, в котором есть определенная инфа:
каким образом отвечается, 
статус код, 
тело ответа, 
хранящиеся куки и тд..
Клиентом в понимании CSA может быть кто угодно, кто спрашивает, в том числе и сам сервак который спрашивает у другого сервера и десктопный и мобильный и веб и любой клиент.
Сервером может быть опять же любой кто отвечает: и холодильник (если там стоит микросхема и она с веб-сервисом, и может что-то отвечать), и утюг, и стиралка, и телефон, и бытовой комп..

Физически мы привыкли видеть сервером - DataCenter, это тоже сервер (промышленный), который сделан специально для этой функциональности, но, по сути, бытовые варианты отличаются от DataCenter только спецификацией сборки и комплектующими (процессором, оперативной памятью, форм-фактором, и тд.).

Сервером может быть - любая железяка, в которую встроен процессор(с базовым софтом, чтобы он работал), оперативная память, у которой есть модули манипулирования электричеством в цепи и др. комп компонентов.

Но без операционной системы, любая железяка любых размеров, с любой оперативной памятью, процессором, другими самыми большими качественными составляющими и т.д., не имеет никакой ценности, это просто кирпич.

90-95 % в мире серверов работает на ОС Linux, дистрибутивов много, но Linux - общий. Linux хороша под серверные задачи (хорошо конфигурируемая, настраиваемая, бесплатная, рабочая). Конфигурации Linux и поддержка могут стоить денег, но сам Linux - можно просто и бесплатно скачать и пользоваться. 

То что мы делали в терминале это как раз Linux, чтобы залезть в Linux, есть 2 пути это 
через терминал (GitBash) по файловой системе:
,либо 
через файловый просмотрщик (FileZilla) если маленькая задача (наприм.: залить 1 файл)
5% промышленные сервера или банковские сервера или др сложные системы которые интегрированы для работы с Windows это Windows-сервер.
НО суперкомпьютеры работают на Linux ( для петафлопс вычислений, больших облачных вычислений, научных целей и тд.)

![image_1](https://sun9-31.userapi.com/impg/q1lX3TgVaVMM9LXvuvYL_G_h5h2p2O0pNGONJA/_u37AsE-W3Y.jpg?size=814x516&quality=95&sign=b71e52b9257b65eb89ae95aa5e94a6f3&type=album)

![image_2](https://sun9-63.userapi.com/impg/fAzEEDYFk1aBW1ILKCxSnSxYO2q7Ok8fP_yfNA/l2w6pw_k3fA.jpg?size=859x453&quality=95&sign=c700defdb45d9146d80a9d4cfc3d1c97&type=album)
Нажатие на кнопку login является одним из ивентов для запуска javascript который провалидирует, что мы написали(не есть ли пользователь, а правильные ли символы ввели). 
Почти под каждой кнопкой на ui интерфейсе пользователя frontend программисты пишут ip, порт и endpoint в который летит запрос(методом POST) на сервер (endpoint /loginuser), backend программисты прописали, что делать серверу если в него постучались по этому endpoint (там по умолчанию ожидается метод POST), и инфа о usere скорее всего лежит в body запроса, т.е сервер залазит и достает из тела запроса инфу(возможно проведя валидацию usera) и спрашивает у DB есть ли такой пользователь(идентификация), после этого “сверяет” пароль (аутентификация), проверяет роль userа, и понимает, что именно хочет получить user, новый запрос “дай инфу”. Далее следуют несколько вариантов развития:
1.Рендеринг(сервер берет html/css данные которые он достал из базы и прямо на сервере в html вставляет данные в нужные теги),
2.Достает пачку данных html, css, javascript json c данными из базы, пакуется в ответ и отправляется на клиент и javascript на клиенте, берет часть данных из json и вставляет в нужное место в html и после логина видим то что есть в личном кабинете после login.
